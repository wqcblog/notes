String 类里也提供了如下几个特殊的方法。

- boolean matches(String regex)：判断该字符串是否匹配指定的正则表达式。
- String replaceAll(String regex, String replacement)：将该字符串中所有匹配 regex 的子串替换成 replacement。
- String replaceFirst(String regex, String replacement)：将该字符串中第一个匹配 regex 的子串替换成 replacement。
- String[] split(String regex)：以 regex 作为分隔符，把该字符串分割成多个子串。

Java 还提供了 Pattern 和 Matcher 两个类专门用于提供正则表达式支持。

## 支持的合法字符

| 字符   | 解释                                                         |
| ------ | ------------------------------------------------------------ |
| X      | 字符x（x 可代表任何合法的字符)                               |
| \0mnn  | 八进制数 0mnn 所表示的字符                                   |
| \xhh   | 十六进制值 0xhh 所表示的字符                                 |
| \uhhhh | 十六进制值 0xhhhh 所表示的 Unicode 字符                      |
| \t     | 制表符（“\u0009”）                                           |
| \n     | 新行（换行）符（‘\u000A’）                                   |
| \r     | 回车符（‘\u000D’)                                            |
| \f     | 换页符（‘\u000C’）                                           |
| \a     | 报警（bell）符（‘\u0007’）                                   |
| \e     | Escape 符（‘\u001B’）                                        |
| \cx    | x 对应的的控制符。例如，`\cM`匹配 Ctrl-M。x 值必须为 A~Z 或 a~z 之一。 |

## 特殊字符

| 特殊字符 | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| $        | 匹配一行的结尾。要匹配 $ 字符本身，请使用`\$`                |
| ^        | 匹配一行的开头。要匹配 ^ 字符本身，请使用`\^`                |
| ()       | 标记子表达式的开始和结束位置。要匹配这些字符，请使用`\(`和`\)` |
| []       | 用于确定中括号表达式的开始和结束位置。要匹配这些字符，请使用`\[`和`\]` |
| {}       | 用于标记前面子表达式的出现频度。要匹配这些字符，请使用`\{`和`\}` |
| *        | 指定前面子表达式可以出现零次或多次。要匹配 * 字符本身，请使用`\*` |
| +        | 指定前面子表达式可以出现一次或多次。要匹配 + 字符本身，请使用`\+` |
| ?        | 指定前面子表达式可以出现零次或一次。要匹配 ？字符本身，请使用`\?` |
| .        | 匹配除换行符`\n`之外的任何单字符。要匹配`.`字符本身，请使用`\.` |
| \        | 用于转义下一个字符，或指定八进制、十六进制字符。如果需匹配`\`字符，请用`\\` |
| \|       | 指定两项之间任选一项。如果要匹配`丨`字符本身，请使用`\|`     |

```
"\u0041\\\\" // 匹配 A\
"\u0061\t"  // 匹配a<制表符>
"\\?\\["    // 匹配？[
```

## 预定义字符("通配符")

| 代码/语法 | 说明             |
| --------- | ---------------- |
| *         | 重复零次或更多次 |
| +         | 重复一次或更多次 |
| ?         | 重复零次或一次   |
| {n}       | 重复n次          |
| {n,}      | 重复n次或更多次  |
| {n,m}     | 重复n到m次       |

| 预定义字符 | 说明                                                         |
| ---------- | ------------------------------------------------------------ |
| .          | 可以匹配任何字符                                             |
| \d         | 匹配 0~9 的所有数字                                          |
| \D         | 匹配非数字                                                   |
| \s         | 匹配所有的空白字符，包括空格、制表符、回车符、换页符、换行符等 |
| \S         | 匹配所有的非空白字符                                         |
| \w         | 匹配所有的单词字符，包括 0~9 所有数字、26 个英文字母和下画线`_` |
| \W         | 匹配所有的非单词字符                                         |

```
c\\wt    // 可以匹配cat、cbt、cct、cOt、c9t等一批字符串
\\d\\d\\d-\\d\\d\\d-\\d\\d\\d\\d    // 匹配如 000-000-0000 形式的电话号码
```

## 方括号表达式

| 方括号表达式     | 说明                                                         |
| ---------------- | ------------------------------------------------------------ |
| 表示枚举         | 例如`[abc]`表示 a、b、c 其中任意一个字符；`[gz]`表示 g、z 其中任意一个字符 |
| 表示范围：-      | 例如`[a-f]`表示 a~f 范围内的任意字符；`[\\u0041-\\u0056]`表示十六进制字符 \u0041 到 \u0056 范围的字符。范围可以和枚举结合使用，如`[a-cx-z]`，表示 a~c、x~z 范围内的任意字符 |
| 表示求否：^      | 例如`[^abc]`表示非 a、b、c 的任意字符；`[^a-f]`表示不是 a~f 范围内的任意字符 |
| 表示“与”运算：&& | 例如 `[a-z&&[def]]`是 a~z 和 [def] 的交集，表示 d、e `f[a-z&&^bc]]`是 a~z 范围内的所有字符，除 b 和 c 之外 `[ad-z] [a-z&&[m-p]]`是 a~z 范围内的所有字符，除 m~p 范围之外的字符 |
| 表示“并”运算     | 并运算与前面的枚举类似。例如`[a-d[m-p]]`表示 [a-dm-p]        |

例如，若需要匹配所有的中文字符，就可以利用 [\\u0041-\\u0056] 形式。

## 子表达式

正则表达式还支持圆括号，用于将多个表达式组成一个子表达式，圆括号中可以使用或运算符`|`。例如，正则表达式“((public)|(protected)|(private))”用于匹配 Java 的三个访问控制符其中之一。

## 边界匹配

| 边界匹配符 | 说明                           |
| ---------- | ------------------------------ |
| ^          | 行的开头                       |
| $          | 行的结尾                       |
| \b         | 单词的边界                     |
| \B         | 非单词的边界                   |
| \A         | 输入的开头                     |
| \G         | 前一个匹配的结尾               |
| \Z         | 输入的结尾，仅用于最后的结束符 |
| \z         | 输入的结尾                     |

## 匹配模式

建立一个匹配 000-000-0000 形式的电话号码时，可以使用 \\d\\d\\d-\\d\\d\\d-\\d\\d\\d\\d 正则表达式，这看起来比较烦琐。实际上，正则表达式还提供了数量标识符，正则表达式支持的数量标识符有如下几种模式。

- Greedy（贪婪模式）：数量表示符默认采用贪婪模式，除非另有表示。贪婪模式的表达式会一直匹配下去，直到无法匹配为止。如果你发现表达式匹配的结果与预期的不符，很有可能是因为你以为表达式只会匹配前面几个字符，而实际上它是贪婪模式，所以会一直匹配下去。
- Reluctant（勉强模式）：用问号后缀（?）表示，它只会匹配最少的字符。也称为最小匹配模式。
- Possessive（占有模式）：用加号后缀（+）表示，目前只有 Java 支持占有模式，通常比较少用。

| 代码/语法 | 说明                            |
| --------- | ------------------------------- |
| *?        | 重复任意次，但尽可能少重复      |
| +?        | 重复1次或更多次，但尽可能少重复 |
| ??        | 重复0次或1次，但尽可能少重复    |
| {n,m}?    | 重复n到m次，但尽可能少重复      |
| {n,}?     | 重复n次以上，但尽可能少重复     |

```java
String str = "hello, java!";
// 贪婪模式的正则表达式
System.out.println(str.replaceFirst("\\w*" , "■"));    //输出■,java!
// 勉强模式的正则表达式
System.out.println(str.replaceFirst("\\w*?" , "■""));    //输出■hello, java!
```

当从“hello java!”字符串中查找匹配`\\w*`子串时，因为`\w*`使用了贪婪模式，数量表示符`*`会一直匹配下去，所以该字符串前面的所有单词字符都被它匹配到，直到遇到空格，所以替换后的效果是“■，Java!”；如果使用勉强模式，数量表示符`*`会尽量匹配最少字符，即匹配 0 个字符，所以替换后的结果是“■hello，java!”。

