# 数据结构与算法

## 大纲内容

主要内容：数据表示，数据关系，数据操作(算法)

涵盖内容：
（1）逻辑结构：

- 线性结构：线性表，栈，队，串，数组
- 非线性结构：树结构，图结构

（2）物理/存储结构

顺序结构(静态)，链式结构(动态)，索引结构，散列结构

（3）数据操作

插入运算，删除运算，修改运算，查找运算，排序运算

**数据结构+算法=程序设计**

## 数据结构

目的：寻求合适的数据结构

研究数据的逻辑结构和物理/存储结构以及之间的相互的关系，并对这种结构定义相应的运算。

逻辑结构：集合结构，线性结构，树状结构，图/网状结构

物理/存储结构：顺序映像/存储与非顺序映像/存储（数组，链表）

## 算法

目的：寻求最佳解决方案

算法设计——逻辑结构

算法实现——存储结构

### 算法的特性

- 有限性：不能形成无穷循环
- 确定性：步骤确定，无二义性
- 输入：有多个或0个输入
- 输出：至少有一个或多个输出
- 可行性/有效性：执行有限次可完成

算法用程序设计语言描述即为可执行源程序。

### 算法设计要求

正确性——可行性

可读性——方便阅读修改

健壮性——允许出错 报告原因 

高效率与低存储量——最佳性能

## 算法描述的工具

- 人类语言
- 伪代码（简易符号）
- **流程图(优选 简明易懂)**
- 程序源代码

## 算法的性能评价

分析算法的时空复杂度(反映程序执行时间随输入规模增长而增长的量级)。

### 时间复杂度

背景：算法执行所需的时间与算法中语句的执行次数成正比例，把算法中的语句执行次数称为语句频度或时间频度（记为T(n)   n为问题的规模），因此分析T(n)即可分析执行效率。

**定义**： 算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=Ｏ(f(n)),称Ｏ(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。大O表示法一般是指最差情况的时间复杂度(数据随机)。

**注意**：f(n)要取尽可能简单的函数 例如**O(2n^2+n +1) = O (3n^2+n+3) = O (7n^2 + n) = O ( n^2 )** 

​            因此时间频度不同，但是时间复杂度可能相同

**常见**：Ο(1)＜Ο(log2 n)＜Ο(n)＜Ο(nlog2 n)＜Ο(n^2)＜Ο(n^3)＜…＜Ο(2^n)＜Ο(n!)<O(n^n)

尽可能选用多项式阶O(n^k)的算法，而不希望用指数阶的算法。

当问题规模不断扩大，上述的算法效率排序就会显现（可能在问题规模很小时不符合上述规律）

**补充：**

Ο(1) Ο(log2 n) Ο(n) Ο(nlog2 n) Ο(n^2) Ο(n^3) 称为多项式时间，而Ο(2^n) Ο(n!)称为指数时间。

前者（即多项式时间复杂度的算法）是有效算法，把这类问题称为P（Polynomial,多项式）类问题

后者（即指数时间复杂度的算法）称为NP（Non-Deterministic Polynomial, 非确定多项式）问题

**具体求解：**

　　(1) 找出算法中的基本语句

　　算法中执行次数最多的那条语句就是基本语句，循环体通常是最内层。

　　(2) 大O记号中为基本语句的执行次数

​         循环并列则相加，循环嵌套则相乘。或者多重循环转化为单重循环去分析。

```
　　for (i=1; i<=n; i++)
　　       x++;
　　for (i=1; i<=n; i++)
　     　for (j=1; j<=n; j++)
　　          x++;
```


　　分析：第一个for循环的时间复杂度为Ο(n)，第二个for循环的时间复杂度为Ο(2n^2)，则整个算法的时间复杂度为Ο(n+2n^2)=Ο(n^2)。

**法则**

(1)对于一些简单的输入输出语句或赋值语句,近似认为需要O(1)时间

​    Ο(1)表示基本语句的执行次数是一个常数，只要算法中不存在循环语句，其时间复杂度就是Ο(1)。

(2)对于顺序结构,需要依次执行一系列语句所用的时间可采用大O下"求和法则"

求和法则:是指若算法的2个部分时间复杂度分别为 T1(n)=O(f(n))和 T2(n)=O(g(n)),则 T1(n)+T2(n)=O(max(f(n), g(n)))

特别地,若T1(m)=O(f(m)), T2(n)=O(g(n)),则 T1(m)+T2(n)=O(f(m) + g(n))

(3)对于选择结构,如if语句,它的主要时间耗费是在执行then字句或else字句所用的时间,需注意的是检验条件需要的是O(1)时间

(4)对于循环结构,循环语句的运行时间主要体现在多次迭代中执行循环体以及检验循环条件的时间耗费,一般可用大O下"乘法法则"

乘法法则: 是指若算法的2个部分时间复杂度分别为 T1(n)=O(f(n))和 T2(n)=O(g(n)),则 T1*T2=O(f(n)*g(n))

(5)对于复杂的算法,可以将它分成几个容易估算的部分,然后利用求和法则和乘法法则计算整个算法的时间复杂度

特殊的法则:(1) 若g(n)=O(f(n)),则O(f(n))+ O(g(n))= O(f(n))；(2) O(Cf(n)) = O(f(n)),其中C是一个正常数

**示例**

(1)O(1)

        Temp=i; i=j; j=temp;                    

以上三条单个语句的频度均为1，该程序段的执行时间是一个与问题规模n无关的常数。算法的时间复杂度为常数阶，记作T(n)=O(1)。注意：如果算法的执行时间不随着问题规模n的增加而增长，即使算法中有上千条语句，其执行时间也不过是一个较大的常数。此类算法的时间复杂度是O(1)。
(2)O(n^2)

     sum=0；                 （一次）
     for(i=1;i<=n;i++)     （n+1次）
        for(j=1;j<=n;j++) （n2次）
         sum++；            （n2次）

O(2n^2+n+1)=O(n^2)（去低阶项，去掉常数项，去掉高阶项的常参得到），所以T(n)=O(n^2)；

```
   for (i=1;i<n;i++)
    { 
        y=y+1;         ①   
        for (j=0;j<=(2*n);j++)    
           x++;         ②      
    }      
```

​    解： 语句1的频度是n-1
​          语句2的频度是(n-1)*(2n+1)=2n^2-n-1
​          f(n)=2n^2-n-1+(n-1)=2n^2-2；

​         又O(2n^2-2)=n^2
​          该程序的时间复杂度T(n)=O(n^2).  

　　一般情况下，对步进循环语句只需考虑循环体中语句的执行次数，忽略该语句中步长加1、终值判别、控制转移等成分，当有若干个循环语句时，算法的时间复杂度是由嵌套层数最多的循环语句中最内层语句的频度f(n)决定的。     

(3)O(n)                                                              

```
  a=0;
    b=1;                      ①
    for (i=1;i<=n;i++) ②
    {  
       s=a+b;　　　　③
       b=a;　　　　　④  
       a=s;　　　　　⑤
    }
```

解： 语句1的频度：2,       

​         语句2的频度： n,       

​          语句3的频度： n-1,       

​          语句4的频度：n-1,   

​          语句5的频度：n-1,                                 

​          T(n)=2+n+3(n-1)=4n-1=O(n).
(4)O(log2 n)

     i=1;     ①
    while (i<=n)
       i=i*2; ②

解： 语句1的频度是1, 
          设语句2的频度是f(n),   则：2^f(n)<=n;    f(n)<=log2 n  

​          取最大值f(n)=log2 n,
​          T(n)=O(log2 n )

(5)O(n^3) 

```
 for(i=0;i<n;i++)
    {  
       for(j=0;j<i;j++)  
       {
          for(k=0;k<j;k++)
             x=x+2;  
       }
    }
```


解：当i=m, j=k的时候,内层循环的次数为k当i=m时, j 可以取 0,1,...,m-1 , 所以这里最内循环共进行了0+1+...+m-1=(m-1)m/2次,所以i从0取到n, 则循环共进行了: 0+(1-1)*1/2+...+(n-1)n/2=n(n+1)(n-1)/6所以时间复杂度为O(n3).

### 空间复杂度

空间复杂度不是计算问题本身要使用的空间，而是要计算算法所需要的辅助空间，与问题的规模没有关系，所消耗空间的数量级用S(n)=O(f(n))表示。

（1）算法执行时所需要的辅助空间不随输入的数据量变化而变化则称这个算法的辅助空间为O(1)。
（2）递归算法的空间复杂度计算：递归深度*每次递归所创建的对象个数（辅助空间）。如果每次递归所需的辅助空间是常数(每次递归都去创建该空间的情况下)，则递归的空间复杂度是 O(N)。

（3）当一个算法的空间复杂度与以2为底的n的对数成正比时，可表示为0(log2 n)；当一个算法的空间复杂度与n成线性比例关系时，可表示为0(n).

常见的节省空间方式：若形参为数组，则只需要为它分配一个存储由实参传送来的一个地址指针的空间，即一个机器字长空间；若形参为引用方式，则也只需要为其分配存储一个地址的空间，用它来存储对应实参变量的地址，以便由系统自动引用实参变量。

### 递归复杂度的计算

1、递归算法的时间复杂度计算：
递归算法的时间复杂度=递归总次数*每次递归次数。
2、递归算法的空间复杂度计算：
 递归算法的空间复杂度=递归深度x每次递归所创建的对象个数。



