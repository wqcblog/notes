## 数据类型

C#是一种强类型语言，要求每个变量必须指定数据类型。

C#语言的数据类型分为值类型和引用类型。

值类型包括整型、浮点型、字符型、布尔型、枚举型等；引用类型包括类、接口、数组、委托、字符串等。

从内存存储空间的角度而言，值类型的值是存放到栈中的，每次存取值都会在该内存中操作；引用类型首先会在栈中创建一个引用变量，然后在堆中创建对象本身，再把这个对象所在内存的首地址赋给引用变量。

### 整型

| 类 型  | 取值范围                           |
| ------ | ---------------------------------- |
| sbyte  | 有符号数，占用1个字节，-27〜27-1   |
| byte   | 无符号数，占用1个字节，0〜28-1     |
| short  | 有符号数，占用2个字节，-215〜215-1 |
| ushort | 无符号数，占用2个字节，0〜216-1    |
| int    | 有符号数，占用4个字节，-231〜231-1 |
| uint   | 无符号数，占用4个字节，0〜232-1    |
| long   | 有符号数，占用8个字节，-263〜263-1 |
| ulong  | 无符号数，占用8个字节，0〜264-1    |

**注意：**short、int 和 long 类型所对应的无符号数类型都是在其类型名称前面加上了 u 字符，只有 byte 类型比较特殊，它存储一个无符号数，其对应的有符号 数则是 sbyte。

默认的整型是int类型。

### 浮点型

| 类 型  | 取值范围                                    |
| ------ | ------------------------------------------- |
| float  | 单精度浮点型，占用4个字节，最多保留7位小数  |
| double | 双精度浮点型，占用8个字节，最多保留16位小数 |

在 C# 语言中默认的浮点型是 double 类型。如果要使用单精度浮点型，需要在数值后 面加上 f 或 F 来表示，例如 123.45f、123.45F。

### 字符型和字符串类型

字符型只能存放一个字符，占两个字节，使用char关键字，使用单引号包围。

字符串类型是一个引用类型，使用String关键字，需要使用双引号包围(存放的字数没有限制)。

| 转义字符 | 等价字符           |
| -------- | ------------------ |
| \'       | 单引号             |
| \"       | 双引号             |
| \\       | 反斜杠             |
| \0       | 空                 |
| \a       | 警告（产生蜂鸣音） |
| \b       | 退格               |
| \f       | 换页               |
| \n       | 换行               |
| \r       | 回车               |
| \t       | 水平制表符         |
| \v       | 垂直制表符         |

### 布尔类型

使用bool类型声明，只有true和false两个值

## 运算符

### 算术运算符

| 运算符 | 说 明                  |
| ------ | ---------------------- |
| +      | 对两个操作数做加法运算 |
| -      | 对两个操作数做减法运算 |
| *      | 对两个操作数做乘法运算 |
| /      | 对两个操作数做除法运算 |
| %      | 对两个操作数做取余运算 |

这里需要强调的是：

- 当对两个字符串类型的值使用 + 运算符，代表的是两个字符串值的连接，例如 "123"+"456" 的结果为 "23456" 。
- 当使用 / 运算符时也要注意操作数的数据类型，如果两个操作数的数据类型都为整数，那么结果相当于取整运算，不包括余数；而两个操作数中如果有一个操作数的数据类型为浮点数，那么结果则是正常的除法运算。
- 当使用 % 运算符时，如果两个操作都为整数，那么结果相当于取余数。经常使用该运算符来判断某个数是否能被其他的数整除。

### 逻辑运算符

逻辑运算符主要包括与、或、非等，它主要用于多个布尔型表达式之间的运算。

| 运算符 | 含义   | 说明                                                         |
| ------ | ------ | ------------------------------------------------------------ |
| &&     | 逻辑与 | 如果运算符两边都为 True，则整个表达式为 True,否则为 False;如果左边操作数为 False，则不对右边表达式进行计算，相当于“且”的含义 |
| \|\|   | 逻辑或 | 如果运算符两边有一个或两个为 True，整个表达式为 True，否则为 False;如果左边为 True,则不对右边表达式进行计算，相当于“或”的含义 |
| !      | 逻辑非 | 表示和原来的逻辑相反的逻辑                                   |

### 比较运算符

比较运算符是在条件判断中经常使用的一类运算符，包括大于、小于、不等于、大于等于、小于等于等，具体的符号说明如下表所示。

| 运算符 | 说 明                                        |
| ------ | -------------------------------------------- |
| ==     | 表示两边表达式运算的结果相等，注意是两个等号 |
| !=     | 表示两边表达式运算的结果不相等               |
| >      | 表示左边表达式的值大于右边表达式的值         |
| <      | 表示左边表达式的值小于右边表达式的值         |
| >=     | 表示左边表达式的值大于等于右边表达式的值     |
| <=     | 表示左边表达式的值小于等于右边表达式的值     |

使用比较运算符运算得到的结果是布尔型的值，因此经常将使用比较运算符的表达式用到逻辑运算符的运算中。

### 位运算符

所谓的位运算，通常是指将数值型的值从十进制转换成二进制后的运算，由于是对二进制数进行运算，所以使用位运算符对操作数进行运算的速度稍快。

| 运算符 | 说 明                                                        |
| ------ | ------------------------------------------------------------ |
| &      | 按位与。两个运算数都为 1，则整个表达式为 1，否则为 0;也可以对布尔型的值进行比较，相当于“与”运算，但不是短路运算 |
| \|     | 按位或。两个运算数都为 0，则整个表达式为 0，否则为 1;也可以对布尔型的值进行比较，相当于“或”运算，但不是短路运算 |
| ~      | 按位非。当被运算的值为 1 时，运算结果为 0;当被运算的值为 0 时，运算结果为 1。该操作符不能用于布尔型。对正整数取反，则在原来的数上加 1，然后取负数；对负整数取反，则在原来的数上加 1，然后取绝对值 |
| ^      | 按位异或。只有运算的两位不同结果才为 1，否则为 0             |
| <<     | 左移。把运算符左边的操作数向左移动运算符右边指定的位数，右边因移动空出的部分 补 0 |
| >>     | 有符号右移。把运算符左边的操作数向右移动运算符右边指定的位数。如果是正值，左侧因移动空出的部分补 0;如果是负值，左侧因移动空出的部分补 1 |
| >>>    | 无符号右移。和 >> 的移动方式一样，只是不管正负，因移动空出的部分都补 0 |

在上面列出的运算符中比较常用的是左移运算符和右移运算符，左移 1 位相当于将操作数乘 2，右移 1 位相当于将操作数除 2。

### 三元运算符

> 布尔表达式 ? 表达式 1: 表达式 2

其中：

- 布尔表达式：判断条件，它是一个结果为布尔型值的表达式。
- 表达式 1:如果布尔表达式的值为 True，该三元运算符得到的结果就是表达式 1 的运算结果。
- 表达式 2:如果布尔表达式的值为 False，该三元运算符得到的结果就是表达式 2 的运算结果。

### 赋值运算符

赋值运算符如下表所示。

| 运算符 | 说 明                                                        |
| ------ | ------------------------------------------------------------ |
| =      | x=y，等号右边的值给等号左边的变量，即把变量 y 的值赋给变量 x |
| +=     | x+=y，等同于 x=x+y                                           |
| -=     | x-=y，等同于 x=x-y                                           |
| *=     | x*=y，等同于 x=x*y                                           |
| /=     | x/=y，等同于 x=x/y                                           |
| %=     | x%=y，等同于 x=x%y，表示求 x 除以 y 的余数                   |
| ++     | x++ 或 ++x，等同于 x=x+1                                     |
| --     | x-- 或 --x，等同于 x=x-1                                     |

### 运算符的优先级

| 运算符                                                       | 结合性   |
| ------------------------------------------------------------ | -------- |
| .（点）、()（小括号）、[]（中括号）                          | 从左到右 |
| + （正）、-（负）、++ （自增）、--（自减）、~（按位非）、!（逻辑非） | 从右到左 |
| * （乘）、/ （除）、% （取余）                               | 从左向右 |
| + （加）、-（减）                                            | 从左向右 |
| <<、>>、>>>                                                  | 从左向右 |
| <、<=、>、>=                                                 | 从左向右 |
| ==、!=                                                       | 从左向右 |
| &                                                            | 从左向右 |
| \|                                                           | 从左向右 |
| ^                                                            | 从左向右 |
| &&                                                           | 从左向右 |
| \|\|                                                         | 从左向右 |
| ?:                                                           | 从右到左 |
| =、+=、-=、*=、/=、%=、&=、\|=、^=、~=、<<=、>>=、>>>=       | 从右到左 |

## 变量

两个变量交换值的三种实现方式

```cs
class Program
{
    static void Main(string[] args)
    {
        int a = 100;
        int b = 200;
        Console.WriteLine("交换前：");
        Console.WriteLine("a=" + a + ";b=" + b);
        int temp;
        temp = a;
        a = b;
        b = temp;
        Console.WriteLine("交换后：");
        Console.WriteLine("a=" + a + ";b=" + b);
    }
}
//定义临时变量
```

```cs
class Program
{
    static void Main(string[] args)
    {
        int a = 100;
        int b = 200;
        a = a + b;
        b = a - b;
        a = a - b;
        Console.WriteLine("交换后的值：");
        Console.WriteLine("a=" + a + ";b=" + b);
    }
}
//加和再减
```

```cs
class Program
{
    static void Main(string[] args)
    {
        int a = 100;
        int b = 200;
        a = a ^ b;
        b = a ^ b;
        a = a ^ b;
        Console.WriteLine("交换后的值：");
        Console.WriteLine("a=" + a + ";b=" + b);
    }
}
//使用位运算
```

## 常量

>const 数据类型 常量名 = 值;

## 变量命名规则

常用的命名方法有两种，一种是 Pascal 命名法（帕斯卡命名法），另一种是 Camel 命名法（驼峰命名法）。

Pascal 命名法是指每个单词的首字母大写；Camel 命名法是指第一个单词小写，从第二个单词开始每个单词的首字母大写。

###  变量的命名规则

变量的命名规则遵循 Camel 命名法，并尽量使用能描述变量作用的英文单词。例如存放学生姓名的变量可以定义成 name 或者 studentName 等。另外，变量名字也不建议过长， 最好是 1 个单词，最多不超过 3 个单词。

### 常量的命名规则

为了与变量有所区分，通常将定义常量的单词的所有字母大写。例如定义求圆面积的 n 的值，可以将其定义成一个常量以保证在整个程序中使用的值是统一的，直接定义成 PI 即可。

### 类的命名规则

类的命名规则遵循 Pascal 命名法，即每个单词的首字母大写。例如定义一个存放学生信息的类，可以定义成 Student。

### 接口的命名规则

接口的命名规则也遵循 Pascal 命名法，但通常都是以 I 开头，并将其后面的每个单词的首字母大写。例如定义一个存放值比较操作的接口，可以将其命名为 ICompare。

### 方法的命名规则

方法的命名遵循 Pascal 命名法，一般采用动词来命名。例如实现添加用户信息操作的方法，可以将其命名为 AddUser。

## goto语句

```cs
goto Labell;
    语句块 1;
Labell
    语句块 2;
```

先执行2后执行1

需要注意的是 goto 语句不能跳转到循环语句中(循环语句中不能设有标签，但标签可以含循环语句)，也不能跳出类的范围。(标签包含范围根据相邻标签而定)。

## 类和对象

### 类的定义

>类的访问修饰符  修饰符  类名
>{
>类的成员
>}

其中：

- 类的访问修饰符：用于设定对类的访问限制，包括 public、internal 或者不写，用 internal 或者不写时代表只能在当前项目中访问类；public 则代表可以在任何项目中访问类。
- 修饰符：修饰符是对类本身特点的描述，包括 abstract、sealed 和 static。abstract 是抽象的意思，使用它修饰符的类不能被实例化；sealed 修饰的类是密封类，不能被继承；static 修饰的类是静态类，不能被实例化。
- 类名：类名用于描述类的功能，因此在定义类名时最好是具有实际意义，这样方便用户理解类中描述的内容。在同一个命名空间下类名必须是唯一的。
- 类的成员：在类中能定义的元素，主要包括字段、属性、方法。

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
namespace code_1
{
    class Test
    {
    }
}
```

尽管可以在一个命名空间中定义多个类，但不建议使用这种方式，最好是每一个文件定义一个类，这样方便阅读和查找。

### 修饰符

**类中成员的访问修饰符**：(包含字段与方法)

- public

成员可以被任何代码访问。

- private

成员仅能被同一个类中的代码访问，如果在类成员前未使用任何访问修饰符，则默认为private。

- internal

成员仅能被同一个项目中的代码访问。

- protected

成员只能由类或派生类中的代码访问。

**字段的修饰符：**

在修饰字段时通常用两个修饰符，即readonly （只读）和static （静态的）。

使用 readonly 修饰字段意味着只能读取该字段的值而不能给字段赋值。

使用 static 修饰的字段是静态字段，可以直接通过类名访问该字段。

需要注意的是常量不能使用 static 修饰符修饰。

字段在类中定义完成后，在类加载时，会自动为字段赋值，不同数据类型的字段默认值不同， 如下表所示。

| 数据类型     | 默认值 |
| ------------ | ------ |
| 整数类型     | 0      |
| 浮点型       | 0      |
| 字符串类型   | 空值   |
| 字符型       | a      |
| 布尔型       | False  |
| 其他引用类型 | 空值   |

**方法的修饰符：**

在定义方法时修饰符包括 virtual（虚拟的）、abstract（抽象的）、override（重写的）、static（静态的）、sealed（密封的）。override 是在类之间继承时使用的。

### get和set访问器

```cs
public 数据类型 属性名
{
    get
    {
        获取属性的语句块;
        return 值;
    }
    set
    {
        设置属性得到语句块;
    }
}
```

当不需要其他逻辑时，使用自动实现更为简洁(语句后面没有分号)。

```cs
public 数据类型 属性名{get;set;}
```

```cs
public int Id{get;}=1; //设置为只读属性，其值为1
```

```cs
public int Id{private get; set;} //get访问器只能在当前类中使用
```

其中：

#### get{}

get 访问器，用于获取属性的值，需要在 get 语句最后使用 return 关键字返回一个与属性数据类型相兼容的值。

若在属性定义中省略了该访问器，则不能在其他类中获取私有类型的字段值，因此也称为**只写属性**。

#### set{}

set 访问器用于设置字段的值，这里需要使用一个特殊的值 value，它就是给字段赋的值。

在 set 访问器省略后无法在其他类中给字段赋值，因此也称为**只读属性**。

### 构造函数与析构函数

```cs
访问修饰符  类名 (参数列表)
{
    语句块；
}
```

```cs
~类名()
{
    语句块；
}
```

### 引用参数与形式参数

引用参数需要在每一个参数(形参与实参)前面加上 ref 关键字修饰。

引用参数与我们平时使用的参数有些类似，但输出参数不同，输出参数相当于返回值,即在方法调用完成后可以将返回的结果存放到输出参数中。

调用带有引用参数的方法时，实际参数必须是一个变量(必须赋值)。

在调用含有带输出参数的方法时，必须在传递参数时使用 out 关键字，但不必给输出参数赋值。

### lambda表达式

```cs
访问修饰符    修饰符    返回值类型    方法名(参数列表) => 表达式;
```

如果在方法定义中定义了返回值类型，在表达式中不必使用 return 关键字，只需要计算值即可。

这种形式只能用在方法中只有一条语句的情况下，方便方法的书写。

```cs
class LambdaClass
{
    public static int Add(int a, int b) => Console.WriteLine(a + b);
}
```

### 嵌套类

嵌套类相当于类中的成员，能使用类成员的访问修饰符和修饰符。但是，在访问嵌套类中的成员时必须加上外层类的名称。

如果在其他类中调用嵌套类的成员，需要使用“外部类.嵌套类”的方式创建嵌套类的对象，从而通过嵌套类的对象调用其成员。

如果调用的是嵌套类中的静态成员，直接通过“外部类 . 嵌套类 . 静态成员”的方式调用即可。

```cs
class OuterClass
{
    public class InnerClass
    {
        public string CardId { get; set; }
        public string Password { get; set; }
        public void PrintMsg()
        {
            Console.WriteLine("卡号为：" + CardId);
            Console.WriteLine("密码为：" + Password);
        }
    }
}
```

```cs
class Program
{
    static void Main(string[] args)
    {
        OuterClass.InnerClass outInner = new OuterClass.InnerClass();
        outInner.CardId = "622211100";
        outInner.Password = "123456";
        outInner.PrintMsg();
    }
}
```

### 部分类

它用于表示一个类中的一部分。

一个类可以由多个部分类构成，定义部分类的语法形式 如下。

>访问修饰符  修饰符  partial class  类名{……}

在这里，partial 即为定义部分类的关键字。部分类主要用于当一个类中的内容较多时将相似类中的内容拆分到不同的类中，并且部分类的名称必须相同。

从该实例可以看出，在不同的部分类中可以直接互相访问其成员，相当于所有的代码都写到一个类中。

此外，在访问类成员时也非常方便，直接通过类的对象即可访问不同部分类的成员。

除了定义部分类外，还可以在部分类中定义部分方法，实现的方式是在一个部分类中定义一个没有方法体的方法，在另一个部分类中完成方法体的内容。

使用部分方法需要注意如下 3 点：

- 部分方法必须是私有的，并且不能使用 virtual、abstract、override、new、sealed、extern 等修饰符。
- 部分方法不能有返回值。
- 在部分方法中不能使用 out 类型的参数。

```cs
public partial class Course
{
    public int Id { get; set; }
    public string Name { get; set; }
    public double Points { get; set; }
    partial void PrintCourse();
    //调用PrintCourse方法
    public void PrintMsg()
    {
        PrintCourse();
    }
}
public partial class Course
{
    public void PrintCoures()
    {
        Console.WriteLine("课程编号：" + Id);
        Console.WriteLine("课程名称：" + Name);
        Console.WriteLine("课程学分：" + Points);
    }
}
```

### Console类

| 方法      | 描述                     |
| --------- | ------------------------ |
| Write     | 向控制台输出内容后不换行 |
| WriteLine | 向控制台输出内容后换行   |
| Read      | 从控制台上读取一个字符   |
| ReadLine  | 从控制台上读取一行字符   |

>Console.Write(格式化字符串, 输出项, 输出项2);

其中，在格式化字符串中使用`{索引号}`的形式，索引号从 0 开始。输出项 1 填充 `{0}` 位置的内容，依此类推。

```cs
class Program
{
    static void Main(string[] args)
    {
        Console.WriteLine("请输入学生姓名：");
        string name = Console.ReadLine();
        Console.WriteLine("请输入所在学校：");
        string school = Console.ReadLine();
        Console.WriteLine("{0}同学在{1}学习", name, school);
    }
}
```

### Math类

| 方法    | 描述                                         |
| ------- | -------------------------------------------- |
| Abs     | 取绝对值                                     |
| Ceiling | 返回大于或等于指定的双精度浮点数的最小整数值 |
| Floor   | 返回小于或等于指定的双精度浮点数的最大整数值 |
| Equals  | 返回指定的对象实例是否相等                   |
| Max     | 返回两个数中较大数的值                       |
| Min     | 返回两个数中较小数的值                       |
| Sqrt    | 返回指定数字的平方根                         |
| Round   | 返回四舍五入后的值                           |

### Random类

Random 类是一个产生伪随机数字的类，它的构造函数有两种。

```cs
New Random()；
New Random(Int32)。
```

前者是根据触发那刻的系统时间做为种子，来产生一个随机数字，后者可以自己设定触发的种子，一般都是用 UnCheck((Int)DateTime.Now.Ticks) 做为参数种子。

因此如果计算机运行速度很快，如果触发 Randm 函数间隔时间很短，就有可能造成产生一样的随机数，因为伪随机的数字，在 Random 的内部产生机制中还是有一定规律的，并非是真正意义上的完全随机。

Random 类中提供的 Next、NextBytes 以及 NextDouble 方法可以生成整数类型、byte 数组类型以及双精度浮点型的随机数，详细说明如下表所示。

| 方法                              | 描述                                                   |
| --------------------------------- | ------------------------------------------------------ |
| Next()                            | 每次产生一个不同的随机正整数                           |
| Next(int max Value)               | 产生一个比 max Value 小的正整数                        |
| Next(int min Value,int max Value) | 产生一个 minValue~maxValue 的正整数，但不包含 maxValue |
| NextDouble()                      | 产生一个0.0~1.0的浮点数                                |
| NextBytes(byte[] buffer)          | 用随机数填充指定字节数的数组                           |

```cs
class Program
{
    static void Main(string[] args)
    {
        Random rd = new Random();
        Console.WriteLine("产生一个10以内的数：{0}", rd.Next(0, 10));
        Console.WriteLine("产生一个0到1之间的浮点数：{0}", rd.NextDouble());
        byte[] b = new byte[5];
        rd.NextBytes(b);
        Console.WriteLine("产生的byte类型的值为：");
        foreach(byte i in b)
        {
            Console.Write(i + " ");
        }
        Console.WriteLine();
    }
}
```

### DateTime类

DateTime 类用于表示时间，所表示的范围是从 0001 年 1 月 1 日 0 点到 9999 年 12 月 31 日 24 点。

在 DateTime 类中提供了静态属性 Now,用于获取当前的日期和时间，如下所示。

>DateTime.Now

DateTime 类提供了 12 个构造方法来创建该类的实例，但经常使用不带参数的方法创建 DateTime 类的实例。

在 DateTime 类中提供了常用的属性和方 法用于获取或设置日期和时间，如下表所示。

| 方法                     | 描述                                     |
| ------------------------ | ---------------------------------------- |
| Date                     | 获取实例的日期部分                       |
| Day                      | 获取该实例所表示的日期是一个月的第几天   |
| DayOfWeek                | 获取该实例所表示的日期是一周的星期几     |
| DayOfYear                | 获取该实例所表示的日期是一年的第几天     |
| Add(Timespan value)      | 在指定的日期实例上添加时间间隔值 value   |
| AddDays(double value)    | 在指定的日期实例上添加指定天数 value     |
| AddHours(double value)   | 在指定的日期实例上添加指定的小时数 value |
| AddMinutes(double value) | 在指定的日期实例上添加指定的分钟数 value |
| AddSeconds(double value) | 在指定的日期实例上添加指定的秒数 value   |
| AddMonths(int value)     | 在指定的日期实例上添加指定的月份 value   |
| AddYears (int value)     | 在指定的日期实例上添加指定的年份 value   |

```cs
class Program
{
    static void Main(string[] args)
    {
        DateTime dt = DateTime.Now;
        Console.WriteLine("当前日期为：{0}", dt);
        Console.WriteLine("当前时本月的第{0}天", dt.Day);
        Console.WriteLine("当前是：{0}", dt.DayOfWeek);
        Console.WriteLine("当前是本年度第{0}天", dt.DayOfYear);
        Console.WriteLine("30 天后的日期是{0}", dt.AddDays(30));
    }
}
```

在使用 DateTime 类中的 Add 方法时需要使用时间间隔类 TimeSpan,该类允许表示的时间间隔范围是 0 到 64 位整数。

两个日期的差可由时间间隔类 TimeSpan 的对象来存放。假设计算现在距离2018年6月1日儿童节的天数，代码如下。

```cs
class Program
{
    static void Main(string[] args)
    {
        DateTime dt1 = DateTime.Now;
        DateTime dt2 = new DateTime(2019, 6, 1);
        TimeSpan ts = dt2 - dt1;
        Console.WriteLine("间隔的天数为{0}天", ts.Days);
    }
}
```

