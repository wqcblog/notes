> 静态成员数据属于整个类，不属于某一个对象。用法：static+数据类型+成员。静态成员数据也分为private与public。静态成员在内存中先于对象的创建而存在。非静态成员在对象创建之后才存在。生命周期决定下列函数的使用规则。

分析类的定义(类名.h)与类函数(类名.cpp):

-   成员函数，构造函数等一般在public中声明，函数的具体定义在cpp文件中
-   运算符的重载直接在函数体内定义或者以友员的形式声明，在cpp文件中定义

分析：.h文件只是一个头文件的作用，需要使用时指出函数进行调用，因此采取分离的形式(声明与定义分开的形式)(优势：比如在这里静态数据成员只被初始化一次)，运算符的重载是对类运算属性的重载，既可以通过友员分离的形式调用，也可以在类的定义中定义，成为内联函数(inline)，提高函数的执行效率。

```
成员函数属于类，成员函数定义是类设计的一部分，其作用域是类作用域，而普通函数一般为全局函数
成员函数的操作主体是对象，使用时通过捆绑对象按来行使职责，而普通函数被调用时没有操作主体
成员函数既可以定义成普通成员函数(非内联函数)，也可以定义成内联成员函数。
普通成员函数的定义：在类的声明中只给出成员函数的原型，而将成员函数的定义放在类的外部。
内联成员函数的定义：
   隐式声明：将成员函数直接定义在类的内部
   显式声明：在类声明中给出成员函数的原型，在类外成员函数的定义前冠以关键字"inline"
```

```cpp
class Student{
private:
  static int count;
public:
  static int m_count;
  static void setcount; //函数的声明与定义分开，否则每定义一次对象就初始化静态成员变量
};   
//成员变量的初始化不能在类的定义中初始化
//静态成员变量必须完成初始化或者一个声明(cpp文件中)
//静态成员变量 public型可以通过类名初始化(也可以通过静态成员函数)  private型只能借助静态成员函数初始化(不能通过动态成员函数)
//静态成员函数只能访问静态成员变量，成员函数都可以对静态成员变量进行数据的修改(不同于初始化)。
//静态成员变量public型可以通过类或对象直接访问,private需要成员函数进行访问
//以上所指的成员函数是指通过类访问的静态成员函数或者创建对象后通过对象访问的成员函数
```

```cpp
int Student::m_ocunt=0;//public型的通过类进行初始化
void Student::setcount(){
   count=0;
}//private型的借助静态成员变量初始化
void testStatic(){
    cout<<Student::m_count<<endl;//类访问
    Student stu;
    //静态成员变量属于类本身，成员函数可以对其进行修改
    cout<<stu.m_count<<endl;//对象访问
    Student *pst=new Student;
    cout<<pst->m_count<<endl;//对象指针访问
    delete pst;
    
    cout<<Student::setcount()<<endl;//通过静态成员函数初始化静态成员变量，并且通过成员函数访问私有变量
}
```

